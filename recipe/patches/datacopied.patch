diff --git a/.github/workflows/wheels.yaml b/.github/workflows/wheels.yaml
index 9cd335074..149383368 100644
--- a/.github/workflows/wheels.yaml
+++ b/.github/workflows/wheels.yaml
@@ -12,16 +12,10 @@ on:
         required: false
         default: 'main'
 
-# Global parameter to turn on/off the windows builds
-# Easier than deleting/commenting out stuff
-env:
-  SISL_BUILD_WINDOWS_WHEELS: ${{ false }}
-
 jobs:
 
   # Build all the wheels with pypa/cibuildwheels
   build_wheels:
-    needs: [define_version]
     name: Build wheel for cp${{ matrix.python }}-${{ matrix.platform_id }}-${{ matrix.manylinux_image }}
     runs-on: ${{ matrix.os }}
     # cibuildwheels already manages multiple python versions automatically
@@ -34,27 +28,23 @@ jobs:
       fail-fast: false
       matrix:
         include:
-          # Window 64 bit
-          - os: windows-latest
-            if: ${{ env.SISL_BUILD_WINDOWS_WHEELS }}
-            python: 37
-            bitness: 64
-            platform_id: win_amd64
-          - os: windows-latest
-            if: ${{ env.SISL_BUILD_WINDOWS_WHEELS }}
-            python: 38
-            bitness: 64
-            platform_id: win_amd64
-          - os: windows-latest
-            if: ${{ env.SISL_BUILD_WINDOWS_WHEELS }}
-            python: 39
-            bitness: 64
-            platform_id: win_amd64
-          - os: windows-latest
-            if: ${{ env.SISL_BUILD_WINDOWS_WHEELS }}
-            python: 310
-            bitness: 64
-            platform_id: win_amd64
+          ## Window 64 bit
+          #- os: windows-latest
+          #  python: 37
+          #  bitness: 64
+          #  platform_id: win_amd64
+          #- os: windows-latest
+          #  python: 38
+          #  bitness: 64
+          #  platform_id: win_amd64
+          #- os: windows-latest
+          #  python: 39
+          #  bitness: 64
+          #  platform_id: win_amd64
+          #- os: windows-latest
+          #  python: 310
+          #  bitness: 64
+          #  platform_id: win_amd64
 
           # Linux 64 bit manylinux2014
           - os: ubuntu-latest
@@ -145,7 +135,7 @@ jobs:
           version: 11
 
       - name: Specify release version
-        if: not startsWith(github.ref, 'refs/tags/v')
+        if: ${{ !startsWith(github.ref, 'refs/tags/v') }}
         run: |
           echo "SETUPTOOLS_SCM_PRETEND_VERION=0.0.1" >> $GITHUB_ENV
 
@@ -180,6 +170,7 @@ jobs:
   # Upload to testpypi
   upload_testpypi:
     needs: [build_sdist, build_wheels]
+    if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags')
     name: Publish package to TestPyPI
     runs-on: ubuntu-latest
     steps:
@@ -205,8 +196,7 @@ jobs:
       fail-fast: false
       matrix:
         include:
-          - os: windows-latest
-            if: ${{ env.SISL_BUILD_WINDOWS_WHEELS }}
+          #- os: windows-latest
           - os: ubuntu-latest
           - os: macos-latest
     steps:
@@ -229,7 +219,7 @@ jobs:
       
       - name: Install sisl + dependencies
         run: |
-          python -m pip install --index-url https://test.pypi.org/simple/ --extra-index-url https://pypi.org/simple/ sisl[test]==0.0.1
+          python -m pip install --index-url https://test.pypi.org/simple/ --extra-index-url https://pypi.org/simple/ sisl[test]
 
       - name: Test the installation
         env:
@@ -242,7 +232,7 @@ jobs:
     needs: [test_testpypi]
     name: Publish package to Pypi
     runs-on: ubuntu-latest
-    if: github.event_name == 'push' && startsWith(github.event.ref, 'refs/tags/v')
+    if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags')
     # alternatively, to publish when a GitHub Release is created, use the following rule:
     # if: github.event_name == 'release' && github.event.action == 'published'
     steps:
@@ -254,4 +244,4 @@ jobs:
       - uses: pypa/gh-action-pypi-publish@v1.4.2
         with:
           user: __token__
-          password: ${{ secrets.PYPI_TOKEN }}
\ No newline at end of file
+          password: ${{ secrets.PYPI_TOKEN }}
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
new file mode 100644
index 000000000..874636e95
--- /dev/null
+++ b/CONTRIBUTING.md
@@ -0,0 +1,44 @@
+# Contributing to sisl
+We love your input! We want to make contributing to this project as easy and transparent as possible, whether it's:
+
+- Reporting a bug
+- Discussing the current state of the code
+- Submitting a fix
+- Proposing new features
+
+## We Develop with GitHub
+We use GitHub to host code, to track issues and feature requests, as well as accept pull requests.
+
+## First-time contributors
+Add a comment on the issue and wait for the issue to be assigned before you start working on it. This helps to avoid multiple people working on similar issues.
+
+## We Use [GitHub Flow](https://guides.github.com/introduction/flow/index.html), So All Code Changes Happen Through Pull Requests
+Pull requests are the best way to propose changes to the codebase (we use [Git-Flow](https://nvie.com/posts/a-successful-git-branching-model/)). We actively welcome your pull requests:
+
+1. Fork the repo and create your branch from `main`. Please create the branch in the format feature/<issue-id>-<issue-name> (eg: feature/176-chart-widget)
+2. If you've added code that should be tested, add tests.
+3. If you've changed APIs, update the documentation.
+4. Ensure the test suite passes.
+5. Issue that pull request!
+
+## Any contributions you make will be under the MPL v2 License
+In short, when you submit code changes, your submissions are understood to be under the same [MPL v2 License](https://www.mozilla.org/en-US/MPL/2.0) that covers the project.
+
+## Report bugs using GitHub's [issues](https://github.com/zerothi/sisl/issues)
+We use GitHub issues to track public bugs. Report a bug by [opening a new issue](https://github.com/zerothi/sisl/issues/new/choose). It's that easy!
+
+**Great Bug Reports** tend to have:
+
+- A quick summary and/or background
+- Steps to reproduce
+  - Be specific!
+  - Give sample code if you can.
+- What you expected would happen
+- What actually happens
+- Notes (possibly including why you think this might be happening, or stuff you tried that didn't work)
+
+## License
+By contributing, you agree that your contributions will be licensed under its MPL v2 License.
+
+## Questions? 
+Contact us on discord [Discord](https://discord.gg/5XnFXFdkv2).
diff --git a/README.md b/README.md
index d128de2e3..c6548ca24 100644
--- a/README.md
+++ b/README.md
@@ -9,99 +9,45 @@
 ![Build Status](https://github.com/zerothi/sisl/actions/workflows/test.yaml/badge.svg?branch=main)
 [![Checkout sisl code coverage](https://codecov.io/gh/zerothi/sisl/branch/main/graph/badge.svg)](https://codecov.io/gh/zerothi/sisl)
 
-## Why sisl ##
+sisl is an *open-source easy-to-use density functional theory API framework* to post-analyse density functional theory codes output
+as well as providing tight-binding calculation capabilities.
+It couples to a wide range of density functional theory codes and has a high connection with LCAO codes such as [Siesta][siesta]. The tight-binding matrices can be used in non-equilibrium Green function calculations with [TBtrans][tbtrans] as a backend. A sub-module exists for creating publication ready graphs and images.
 
-The Python library sisl was born out of a need to handle(create and read), manipulate and analyse output from DFT programs.
-It was initially developed by Nick Papior (co-developer of [Siesta][siesta]) as a side-project to TranSiesta
-and TBtrans to efficiently analyse TBtrans output for N-electrode calculations.  
-Since then it has expanded to accommodate a rich set of DFT code input/outputs such as (but not limited to)
-VASP, OpenMX, BigDFT, Wannier90.
+## Features ##
 
-A great deal of codes are implementing, roughly, the same thing.
-However, every code implements their own analysis and post-processing utilities which typically
-turns out to be equivalent utilities only having the interface differently.
+- *Simple command-line interface*: To extract or quickly plot calculation output
+- *Tight-binding API*: Easily create (non-) orthogonal tight-binding matrices and do Brillouin zone analysis
+- *Post analyse DFT simulations*: Post-process LCAO Hamiltonians by redoing (projected) density of states, inverse participation ration and many more
+- *Post analyse NEGF simulations*: Effectively create and post-analyse NEGF output from [TBtrans][tbtrans]
+- *Real-space grid analysis*: Perform mathematical operations on DFT real-space grid outputs, spin-density differences and wavefunction plots
+- *Conversion of geometries and real-space grid*: Easy conversion of geometry files and real-space grid file formats (cube, xsf, etc.)
+- *User contributed toolboxes*: Users may contribute toolboxes for sharing methodologies
+- *Interoperability with other codes*: [ASE][ase] and [pymatgen]
+- *and many more features*
 
-sisl tries to solve some of the analysis issues by creating a unified scripting approach
-in Python which does analysis using the same interface, regardless of code being used.
-For instance one may read the Kohn-Sham eigenvalue spectrum from various codes and return them
-in a consistent manner so the post-processing is the same, regardless of code being used.
+## Tutorials and examples ##
 
-sisl is also part of the training material for a series of workshops hosted [here][workshop].
+The easiest way to get started is to follow some tutorials [here](https://zerothi.github.io/sisl/tutorials.html) and the workshop material for [TranSiesta][siesta] [here][workshop].
 
-In some regards it has overlap with [ASE][ase] and sisl also interfaces with ASE.
 
-### Example use ###
+## Documentation ##
 
-Here we show 2 examples of using sisl together with [Siesta][siesta].
+Please find documentation here:
 
-To read in a Hamiltonian from a Siesta calculation and calculate the DOS for a given Monkhorst-Pack grid
-one would do:
+- [documentation](https://zerothi.github.io/sisl/index.html)
+- [API documentation](https://zerothi.github.io/sisl/api/index.html)
+- [Installation](https://zerothi.github.io/sisl/installation.html)
 
-    import numpy as np
-    import sisl
-    H = sisl.get_sile('RUN.fdf').read_hamiltonian()
-    mp = sisl.MonkhorstPack(H, [13, 13, 13])
-    E = np.linspace(-4, 4, 500)
-    DOS = mp.apply.average.DOS(E)
-    from matplotlib import pyplot as plt
-    plt.plot(E, DOS)
 
-Which calculates the DOS for a 13x13x13 Monkhorst-Pack grid.
-
-Another common analysis is real-space charge analysis, the following command line subtracts two real-space
-charge grids and writes them to a CUBE file:
-
-    sgrid reference/Rho.grid.nc --diff Rho.grid.nc --geometry RUN.fdf --out diff.cube
-
-which may be analysed using VMD, XCrySDen or other tools.
-
-
-## Installation ##
-
-Installing sisl using PyPi or Conda is the easiest:
-
-    python3 -m pip install sisl
-    python3 -m pip install sisl[analysis] # also installs tqdm and xarray
-    # or
-    conda install -c conda-forge sisl
-
-If performing a manual installation, these packages are required:
-
-   - A C- and fortran-compiler
-   - __Cython__ (0.28 or later)
-   - __numpy__ (1.13 or later)
-   - __scipy__ (0.18 or later)
-   - __netCDF4__
-   - __setuptools__
-   - __setuptools_scm__
-   - __pyparsing__ (1.5.7 or later)
-   - __pytest__, optional dependency for running the tests
-   - __matplotlib__, encouraged optional dependency
-   - __tqdm__, encouraged optional dependency
-   - __xarray__, optional dependency
-   - __plotly__, optional dependency
-
-Subsequently manual installation may be done using this command:
-
-    python3 -m pip install . --prefix=<prefix>
-
-If trying to install without root access, you may be required to use this command:
-
-    python3 -m pip install . --user --prefix=<prefix>
-
-Once installed, the installation can be tested by executing the following:
-
-    pytest --pyargs sisl
-
-## Everyday use of sisl ##
+## Community support ##
 
 There are different places for getting information on using sisl, here is a short list
 of places to search/ask for answers:
 
+- Ask questions on the [Discord page][sisl@discord]
+- Ask questions on the Github [issue page][sisl@issue]
 - [Documentation][sisl@api], recommended reference page
 - [Workshop][workshop] examples showing different uses
-- Ask questions on the Github [issue page][sisl@issue]
-- Ask questions on the [Discord page][sisl@discord]
 
 If sisl was used to produce scientific contributions, please use this [DOI][doi] for citation.
 We recommend to specify the version of sisl in combination of this citation:
@@ -109,7 +55,7 @@ We recommend to specify the version of sisl in combination of this citation:
     @misc{zerothi_sisl,
       author = {Papior, Nick},
       title  = {sisl: v<fill-version>},
-      year   = {2021},
+      year   = {2022},
       doi    = {10.5281/zenodo.597181},
       url    = {https://doi.org/10.5281/zenodo.597181}
     }
@@ -120,24 +66,17 @@ To get the BibTeX entry easily you may issue the following command:
 
 which fills in the version number.
 
-## Help sisl help you! ##
-
-If you have
-
-- ideas of missing features
-- ideas for improving documentation
-- found a bug
-- found a documentation error
-- created a tutorial
-
-Then please share them [here][sisl@issue]!
+## Contributing ##
 
-All of the above may be done via a [pull-request][sisl@pr] or by opening
-an [issue][sisl@issue].
+Kindly read our [Contributing Guide](CONTRIBUTING.md) to learn and understand about our development process, how to propose bug fixes and improvements, and how to build and test your changes to sisl.
 
-Remember:
+## Contributors ##
+<a href="https://github.com/zerothi/sisl/graphs/contributors">
+  <img src="https://contrib.rocks/image?repo=zerothi/sisl" />
+</a>
 
-> No contribution is too small!
+## License
+sisl © 2022, Released under the Mozilla Public License v2.0.
 
 
 <!---
@@ -154,6 +93,7 @@ Links to external and internal sites.
 [doi]: http://dx.doi.org/10.5281/zenodo.597181
 [mpl]: https://www.mozilla.org/en-US/MPL/2.0/
 [ase]: https://wiki.fysik.dtu.dk/ase/
+[pymatgen]: https://pymatgen.org/
 
 <!---
 Local variables for emacs to turn on flyspell-mode
diff --git a/docs/epilog.dummy b/docs/epilog.dummy
index 3b7af459f..3cf2a2180 100644
--- a/docs/epilog.dummy
+++ b/docs/epilog.dummy
@@ -10,8 +10,8 @@
 
 .. These are external links:
 .. _MPL: https://www.mozilla.org/en-US/MPL/2.0/
+.. _Cython: https://cython.org/
 .. _Python: https://www.python.org/
-.. _setuptools: https://pypi.python.org/pypi/setuptools
 .. _NetCDF: https://www.unidata.ucar.edu/netcdf
 .. _netcdf4-py: http://github.com/Unidata/netcdf4-python
 .. _numpy: http://www.numpy.org/
diff --git a/docs/installation.rst b/docs/installation.rst
index cc9efda26..9532b9eb1 100644
--- a/docs/installation.rst
+++ b/docs/installation.rst
@@ -9,10 +9,8 @@ sisl is easy to install using any of your preferred methods.
 Required dependencies
 ---------------------
 
-For installation some basic packages are required:
+For source installations some basic packages are required:
 
-- `setuptools`_
-- `setuptools_scm`_
 - `Cython`_
 - C compiler
 - fortran compiler
diff --git a/docs/visualization/viz_module/showcase/GridPlot.ipynb b/docs/visualization/viz_module/showcase/GridPlot.ipynb
index 074ffc85d..1e4dcea46 100644
--- a/docs/visualization/viz_module/showcase/GridPlot.ipynb
+++ b/docs/visualization/viz_module/showcase/GridPlot.ipynb
@@ -37,6 +37,7 @@
    "source": [
     "import sisl\n",
     "import sisl.viz\n",
+    "import numpy as np\n",
     "# This is just for convenience to retreive files\n",
     "siesta_files = sisl._environ.get_environ_variable(\"SISL_FILES_TESTS\") / \"sisl\" / \"io\" / \"siesta\""
    ]
@@ -335,6 +336,53 @@
     "Not bad."
    ]
   },
+  {
+   "cell_type": "markdown",
+   "metadata": {},
+   "source": [
+    "Volumetric display\n",
+    "----\n",
+    "\n",
+    "Using isosurfaces in the 3D representation, one can achieve a sense of volumetric data. We can do so by asking for **multiple isosurfaces an setting the opacity** of each one properly.\n",
+    "\n",
+    "You can play with it and do the exact thing that you wish. For example, we can represent isosurfaces at increasing values, with the higher values being more opaque:"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "plot.update_settings(\n",
+    "    axes=\"xyz\", isos=[{\"frac\":frac, \"opacity\": frac/2, \"color\": \"green\"} for frac in np.linspace(0.1, 0.8, 20)],\n",
+    ")"
+   ]
+  },
+  {
+   "cell_type": "markdown",
+   "metadata": {},
+   "source": [
+    "The more surfaces you add, the more sense of depth you'll acheive. But of course, it will be more expensive to render.\n",
+    "\n",
+    "<div class=\"alert alert-info\">\n",
+    "    \n",
+    "Note\n",
+    "    \n",
+    "Playing with colors (e.g. setting a colorscale) and not just opacities might give you even a better sense of depth. A way of automatically handling this for you might be introduced in the future.\n",
+    "\n",
+    "</div>"
+   ]
+  },
+  {
+   "cell_type": "code",
+   "execution_count": null,
+   "metadata": {},
+   "outputs": [],
+   "source": [
+    "plot = plot.update_settings(axes=\"xy\", isos=[])"
+   ]
+  },
   {
    "cell_type": "markdown",
    "metadata": {},
@@ -350,7 +398,7 @@
    "metadata": {},
    "outputs": [],
    "source": [
-    "plot.update_settings(isos=[], colorscale=\"temps\")"
+    "plot.update_settings(colorscale=\"temps\")"
    ]
   },
   {
@@ -604,7 +652,7 @@
    "name": "python",
    "nbconvert_exporter": "python",
    "pygments_lexer": "ipython3",
-   "version": "3.7.6"
+   "version": "3.8.12"
   }
  },
  "nbformat": 4,
diff --git a/sisl/io/siesta/_src/hsx_read.f90 b/sisl/io/siesta/_src/hsx_read.f90
index 7ed3e7f40..a675551af 100644
--- a/sisl/io/siesta/_src/hsx_read.f90
+++ b/sisl/io/siesta/_src/hsx_read.f90
@@ -1,7 +1,45 @@
 ! This Source Code Form is subject to the terms of the Mozilla Public
 ! License, v. 2.0. If a copy of the MPL was not distributed with this
 ! file, You can obtain one at https://mozilla.org/MPL/2.0/.
-subroutine read_hsx_sizes(fname, Gamma, nspin, no_u, no_s, maxnh)
+subroutine read_hsx_version(fname, version)
+  use io_m, only: open_file, close_file
+  use io_m, only: iostat_update
+
+  implicit none
+
+  ! Input parameters
+  character(len=*), intent(in) :: fname
+  integer, intent(out) :: version
+
+  ! Define f2py intents
+!f2py intent(in)  :: fname
+!f2py intent(out) :: version
+
+  integer :: iu, ierr
+  integer :: tmp(4)
+
+  call open_file(fname, 'read', 'old', 'unformatted', iu)
+
+  read(iu, iostat=ierr) tmp
+  if ( ierr /= 0 ) then
+    ! we have a version
+    rewind(iu)
+    read(iu, iostat=ierr) version
+    if ( version /= 1 ) then
+      ! Signal we do not know about this file
+      call iostat_update(-3)
+    end if
+  else
+    version = 0
+  end if
+  call iostat_update(ierr)
+
+  call close_file(iu)
+
+end subroutine read_hsx_version
+
+
+subroutine read_hsx_sizes(fname, Gamma, nspin, na_u, no_u, no_s, maxnh)
   use io_m, only: open_file, close_file
   use io_m, only: iostat_update
 
@@ -10,29 +48,161 @@ subroutine read_hsx_sizes(fname, Gamma, nspin, no_u, no_s, maxnh)
   ! Input parameters
   character(len=*), intent(in) :: fname
   logical, intent(out) :: Gamma
-  integer, intent(out) :: nspin, no_u, no_s, maxnh
+  integer, intent(out) :: nspin, na_u, no_u, no_s, maxnh
 
 ! Define f2py intents
 !f2py intent(in)  :: fname
-!f2py intent(out) :: Gamma, nspin, no_u, no_s, maxnh
+!f2py intent(out) :: Gamma, nspin, na_u, no_u, no_s, maxnh
 
-! Internal variables and arrays
+  ! Internal variables and arrays
+  integer :: version, nspecies, nsc(3)
+  integer, allocatable :: numh(:)
+  integer :: i
   integer :: iu, ierr
 
+  call read_hsx_version(fname, version)
+
   call open_file(fname, 'read', 'old', 'unformatted', iu)
 
-! Read overall data
-  read(iu, iostat=ierr) no_u, no_s, nspin, maxnh
-  call iostat_update(ierr)
+  if ( version == 0 ) then ! old
+    ! Read overall data
+    read(iu, iostat=ierr) no_u, no_s, nspin, maxnh
+    call iostat_update(ierr)
+    read(iu, iostat=ierr) gamma
+    call iostat_update(ierr)
+    if ( .not. gamma ) then
+      read(iu, iostat=ierr) !indxuo
+      call iostat_update(ierr)
+    end if
+    read(iu, iostat=ierr) !numh
+    call iostat_update(ierr)
+    do i = 1, no_u * (nspin + 1)
+      read(iu, iostat=ierr) !H and S
+      call iostat_update(ierr)
+    end do
+    read(iu, iostat=ierr) !Qtot, temp
+    call iostat_update(ierr)
+    do i = 1, no_u * (nspin + 1)
+      read(iu, iostat=ierr) !xij
+      call iostat_update(ierr)
+    end do
+    read(iu, iostat=ierr) !nspecies
+    call iostat_update(ierr)
+    read(iu, iostat=ierr) !species-stuff
+    call iostat_update(ierr)
 
-! Read logical
-  read(iu, iostat=ierr) Gamma
-  call iostat_update(ierr)
+    ! TODO add auxiliary info here
+
+    
+  else if ( version == 1 ) then
+
+    read(iu, iostat=ierr) ! version
+    call iostat_update(ierr)
+    read(iu, iostat=ierr) !is_dp
+    call iostat_update(ierr)
+    read(iu, iostat=ierr) na_u, no_u, nspin, nspecies, nsc
+    call iostat_update(ierr)
+    no_s = product(nsc) * no_u
+    Gamma = no_s == no_u
+
+    read(iu, iostat=ierr) !ucell, Ef, qtot, temp
+    call iostat_update(ierr)
+    read(iu, iostat=ierr) !isc_off, xa, isa, lasto(1:na_u)
+    call iostat_update(ierr)
+    read(iu, iostat=ierr) !(label(is), zval(is), no(is), is=1,nspecies)
+    call iostat_update(ierr)
+
+    do is = 1, nspecies
+      read(iu, iostat=ierr) !(nquant(is,io), lquant(is,io), zeta(is,io), io=1,no(is))
+      call iostat_update(ierr)
+    end do
+
+    allocate(numh(no_u))
+    read(iu, iostat=ierr) numh
+    call iostat_update(ierr)
+    maxnh = sum(numh)
+    deallocate(numh)
+
+  end if
 
   call close_file(iu)
 
 end subroutine read_hsx_sizes
 
+subroutine read_hsx_ef(fname, Ef)
+  use io_m, only: open_file, close_file
+  use io_m, only: iostat_update
+
+  implicit none
+
+  ! Input parameters
+  character(len=*), intent(in) :: fname
+  real(dp), intent(out) :: Ef
+
+! Define f2py intents
+!f2py intent(in)  :: fname
+!f2py intent(out) :: Ef
+
+  ! Internal variables and arrays
+  integer :: version
+  real(dp) :: ucell(3,3), qtot, temp
+  integer :: iu, ierr
+
+  call read_hsx_version(fname, version)
+
+  if ( version == 0 ) then ! old
+    Ef = huge(1._dp)
+    return
+  end if
+
+  call open_file(fname, 'read', 'old', 'unformatted', iu)
+
+  if ( version == 1 ) then
+
+    read(iu, iostat=ierr) ! version
+    call iostat_update(ierr)
+    read(iu, iostat=ierr) !is_dp
+    call iostat_update(ierr)
+    read(iu, iostat=ierr) !na_u, no_u, nspin, nspecies, nsc
+    call iostat_update(ierr)
+
+    read(iu, iostat=ierr) ucell, Ef, qtot, temp
+    call iostat_update(ierr)
+
+  end if
+
+  call close_file(iu)
+
+end subroutine read_hsx_ef
+
+
+!< Internal method for skipping species information in version 1 and later
+!< The unit *must* be located just after
+!<     read(iu) isc_off, xa, isa, lasto(1:na_u)
+
+subroutine read_hsx_skip_specie1(iu, nspecies)
+  use io_m, only: open_file, close_file
+  use io_m, only: iostat_update
+  
+  implicit none
+
+  ! Input parameters
+  integer, intent(in) :: iu, nspecies
+
+  ! Internal variables and arrays
+  integer :: ierr
+
+  read(iu, iostat=ierr) !(label(is), zval(is), no(is), is=1,nspecies)
+  call iostat_update(ierr)
+
+  do is = 1, nspecies
+    read(iu, iostat=ierr) !(nquant(is,io), lquant(is,io), zeta(is,io), io=1, no(is))
+    call iostat_update(ierr)
+  end do
+
+end subroutine read_hsx_skip_specie1
+  
+
 subroutine read_hsx_hsx(fname, Gamma, nspin, no_u, no_s, maxnh, &
     numh, listh, H, S, xij)
   use io_m, only: open_file, close_file
@@ -43,6 +213,52 @@ subroutine read_hsx_hsx(fname, Gamma, nspin, no_u, no_s, maxnh, &
   ! Precision 
   integer, parameter :: sp = selected_real_kind(p=6)
 
+  ! Input parameters
+  character(len=*), intent(in) :: fname
+  logical, intent(in) :: Gamma
+  integer, intent(in) :: nspin, no_u, no_s, maxnh
+  integer, intent(out) :: numh(no_u), listh(maxnh)
+  real(dp), intent(out) :: H(maxnh,nspin), S(maxnh), xij(3,maxnh)
+
+! Define f2py intents
+!f2py intent(in) :: fname
+!f2py intent(in) :: Gamma, nspin, no_u, no_s, maxnh
+!f2py intent(out) :: numh, listh
+!f2py intent(out) :: H, S, xij
+
+! Internal variables and arrays
+  integer :: version
+  real(sp), allocatable :: lH(:,:), lS(:), lxij(:,:)
+
+  call read_hsx_version(fname, version)
+
+  if ( version == 0 ) then
+    allocate(lH(maxnh,nspin), lS(maxnh), lxij(3,maxnh))
+    call read_hsx_hsx0((fname, Gamma, nspin, no_u, no_s, maxnh, &
+        numh, listh, lH, lS, lxij)
+    H(:,:) = lH(:,:)
+    S(:) = lS(:)
+    xij(:,:) = lxij(:,:)
+    deallocate(lH, lS, lxij)
+
+  else
+    call read_hsx_hsx1((fname, Gamma, nspin, no_u, no_s, maxnh, &
+        numh, listh, H, S, xij)
+
+  end if
+
+end subroutine read_hsx_hsx
+
+subroutine read_hsx_hsx0(fname, Gamma, nspin, no_u, no_s, maxnh, &
+    numh, listh, H, S, xij)
+  use io_m, only: open_file, close_file
+  use io_m, only: iostat_update
+
+  implicit none
+
+  ! Precision 
+  integer, parameter :: sp = selected_real_kind(p=6)
+
   ! Input parameters
   character(len=*), intent(in) :: fname
   logical, intent(in) :: Gamma
@@ -143,7 +359,133 @@ subroutine read_hsx_hsx(fname, Gamma, nspin, no_u, no_s, maxnh, &
 
   call close_file(iu)
 
-end subroutine read_hsx_hsx
+end subroutine read_hsx_hsx0
+
+subroutine read_hsx_hsx1(fname, Gamma, nspin, no_u, no_s, maxnh, &
+    numh, listh, H, S, xij)
+  use io_m, only: open_file, close_file
+  use io_m, only: iostat_update
+
+  implicit none
+
+  ! Precision 
+  integer, parameter :: sp = selected_real_kind(p=6)
+  integer, parameter :: dp = selected_real_kind(p=14)
+
+  ! Input parameters
+  character(len=*), intent(in) :: fname
+  logical, intent(in) :: Gamma
+  integer, intent(in) :: nspin, no_u, no_s, maxnh
+  integer, intent(out) :: numh(no_u), listh(maxnh)
+  real(dp), intent(out) :: H(maxnh,nspin), S(maxnh), xij(3,maxnh)
+
+! Define f2py intents
+!f2py intent(in) :: fname
+!f2py intent(in) :: Gamma, nspin, no_u, no_s, maxnh
+!f2py intent(out) :: numh, listh
+!f2py intent(out) :: H, S, xij
+
+! Internal variables and arrays
+  integer :: iu, ierr, version
+  integer :: is, ih, im
+  integer, allocatable :: listhptr(:)
+
+  ! Local readables
+  logical :: lGamma, is_dp
+  integer :: lno_s, lno_u, lnspin, lmaxnh
+  integer :: nspecies, nsc(3)
+  real(dp) :: ucell(3,3)
+
+  real(sp), allocatable :: sbuf(:)
+  real(dp), allocatable :: dbuf(:)
+
+  call open_file(fname, 'read', 'old', 'unformatted', iu)
+
+  ! Read overall data
+  read(iu, iostat=ierr) version
+  call iostat_update(ierr)
+  if ( version /= 1 ) then
+    call iostat_update(-4)
+    return
+  end if
+
+  read(iu, iostat=ierr) is_dp
+  call iostat_update(ierr)
+
+  read(iu, iostat=ierr) lna_u, lno_u, lnspin, nspecies, nsc
+  call iostat_update(ierr)
+  if ( lno_u /= no_u ) call iostat_update(-6)
+  if ( lno_u * product(nsc) /= no_s ) call iostat_update(-6)
+  if ( lnspin /= nspin ) call iostat_update(-6)
+  if ( lmaxnh /= maxnh ) call iostat_update(-6)
+
+  ! Read logical
+  read(iu, iostat=ierr) lGamma
+  call iostat_update(ierr)
+  if ( lGamma .neqv. Gamma ) stop 'Error in reading data, not allocated'
+
+! Read out indxuo
+  if (.not. Gamma) then
+    read(iu, iostat=ierr) ! indxuo
+    call iostat_update(ierr)
+  end if
+
+  read(iu, iostat=ierr) numh
+  call iostat_update(ierr)
+
+  ! Create listhptr
+  allocate(listhptr(no_u))
+  listhptr(1) = 0
+  do ih = 2 , no_u
+    listhptr(ih) = listhptr(ih-1) + numh(ih-1)
+  end do
+
+  allocate(buf(maxval(numh)*3))
+
+! Read listh
+  do ih = 1 , no_u
+    im = numh(ih)
+    read(iu, iostat=ierr) listh(listhptr(ih)+1:listhptr(ih)+im)
+    call iostat_update(ierr)
+  end do
+
+! Read Hamiltonian
+  do is = 1 , nspin
+    do ih = 1 , no_u
+      im = numh(ih)
+      read(iu, iostat=ierr) buf(1:im)
+      call iostat_update(ierr)
+      H(listhptr(ih)+1:listhptr(ih)+im,is) = buf(1:im)
+    end do
+  end do
+
+! Read Overlap matrix
+  do ih = 1,no_u
+    im = numh(ih)
+    read(iu, iostat=ierr) buf(1:im)
+    call iostat_update(ierr)
+    S(listhptr(ih)+1:listhptr(ih)+im) = buf(1:im)
+  end do
+
+  read(iu, iostat=ierr) !Qtot,temp
+  call iostat_update(ierr)
+
+  if ( Gamma ) then
+    xij = 0._sp
+  else
+    do ih = 1 , no_u
+      im = numh(ih)
+      read(iu, iostat=ierr) buf(1:im*3)
+      call iostat_update(ierr)
+      xij(1:3,listhptr(ih)+1:listhptr(ih)+im) = reshape(buf(1:im*3),(/3,im/))
+    end do
+  end if
+
+  deallocate(buf, listhptr)
+
+  call close_file(iu)
+
+end subroutine read_hsx_hsx0
 
 subroutine read_hsx_sx(fname, Gamma, nspin, no_u, no_s, maxnh, &
     numh, listh, S, xij)
@@ -169,6 +511,51 @@ subroutine read_hsx_sx(fname, Gamma, nspin, no_u, no_s, maxnh, &
 !f2py intent(out) :: S, xij
 
 ! Internal variables and arrays
+  integer :: version
+  real(sp), allocatable :: lH(:,:), lS(:), lxij(:,:)
+
+  call read_hsx_version(fname, version)
+
+  if ( version == 0 ) then
+    allocate(lS(maxnh), lxij(3,maxnh))
+    call read_hsx_sx0((fname, Gamma, nspin, no_u, no_s, maxnh, &
+        numh, listh, lS, lxij)
+    S(:) = lS(:)
+    xij(:,:) = lxij(:,:)
+    deallocate(lS, lxij)
+
+  else
+    call read_hsx_sx1((fname, Gamma, nspin, no_u, no_s, maxnh, &
+        numh, listh, S, xij)
+
+  end if
+
+end subroutine read_hsx_sx
+
+subroutine read_hsx_sx0(fname, Gamma, nspin, no_u, no_s, maxnh, &
+    numh, listh, S, xij)
+  use io_m, only: open_file, close_file
+  use io_m, only: iostat_update
+
+  implicit none
+
+  ! Precision 
+  integer, parameter :: sp = selected_real_kind(p=6)
+
+  ! Input parameters
+  character(len=*), intent(in) :: fname
+  logical, intent(in) :: Gamma
+  integer, intent(in) :: nspin, no_u, no_s, maxnh
+  integer, intent(out) :: numh(no_u), listh(maxnh)
+  real(sp), intent(out) :: S(maxnh), xij(3,maxnh)
+
+  ! Define f2py intents
+  !f2py intent(in) :: fname
+  !f2py intent(in) :: Gamma, nspin, no_u, no_s, maxnh
+  !f2py intent(out) :: numh, listh
+  !f2py intent(out) :: S, xij
+
+  ! Internal variables and arrays
   integer :: iu, ierr
   integer :: is, ih, im
   integer, allocatable :: listhptr(:)
@@ -189,12 +576,12 @@ subroutine read_hsx_sx(fname, Gamma, nspin, no_u, no_s, maxnh, &
   if ( lnspin /= nspin ) stop 'Error in reading data, not allocated, nspin'
   if ( lmaxnh /= maxnh ) stop 'Error in reading data, not allocated, maxnh'
 
-! Read logical
+  ! Read logical
   read(iu, iostat=ierr) lGamma
   call iostat_update(ierr)
   if ( lGamma .neqv. Gamma ) stop 'Error in reading data, not allocated'
 
-! Read out indxuo
+  ! Read out indxuo
   if (.not. Gamma) then
     read(iu, iostat=ierr) ! indxuo
     call iostat_update(ierr)
@@ -203,7 +590,7 @@ subroutine read_hsx_sx(fname, Gamma, nspin, no_u, no_s, maxnh, &
   read(iu, iostat=ierr) numh
   call iostat_update(ierr)
 
-! Create listhptr
+  ! Create listhptr
   allocate(listhptr(no_u))
   listhptr(1) = 0
   do ih = 2 , no_u
@@ -212,14 +599,14 @@ subroutine read_hsx_sx(fname, Gamma, nspin, no_u, no_s, maxnh, &
 
   allocate(buf(maxval(numh)*3))
 
-! Read listh
+  ! Read listh
   do ih = 1 , no_u
     im = numh(ih)
     read(iu, iostat=ierr) listh(listhptr(ih)+1:listhptr(ih)+im)
     call iostat_update(ierr)
   end do
 
-! Read Hamiltonian
+  ! Read Hamiltonian
   do is = 1 , nspin
     do ih = 1 , no_u
       im = numh(ih)
@@ -228,7 +615,7 @@ subroutine read_hsx_sx(fname, Gamma, nspin, no_u, no_s, maxnh, &
     end do
   end do
 
-! Read Overlap matrix
+  ! Read Overlap matrix
   do ih = 1,no_u
     im = numh(ih)
     read(iu, iostat=ierr) buf(1:im)
@@ -254,7 +641,7 @@ subroutine read_hsx_sx(fname, Gamma, nspin, no_u, no_s, maxnh, &
 
   call close_file(iu)
 
-end subroutine read_hsx_sx
+end subroutine read_hsx_sx0
 
 subroutine read_hsx_specie_sizes(fname, no_u, na_u, nspecies)
   use io_m, only: open_file, close_file
@@ -272,6 +659,43 @@ subroutine read_hsx_specie_sizes(fname, no_u, na_u, nspecies)
 !f2py intent(in) :: fname
 !f2py intent(out) :: no_u, na_u, nspecies
 
+! Internal variables and arrays
+  integer :: iu, ierr, version
+  integer :: is, ih, io
+
+  ! Local readables
+  integer :: lno_s, lnspin, lmaxnh
+  logical :: lGamma
+  character(len=20), allocatable :: labelfis(:)
+  real(dp), allocatable :: zvalfis(:)
+  integer, allocatable :: nofis(:)
+
+  call read_hsx_version(fname, version)
+
+  if ( version == 0 ) then
+    call read_hsx_specie_sizes0(fname, no_u, na_u, nspecies)
+  else if ( version == 1 ) then
+    call read_hsx_specie_sizes1(fname, no_u, na_u, nspecies)
+  end if
+
+end subroutine read_hsx_specie_sizes
+
+subroutine read_hsx_specie_sizes0(fname, no_u, na_u, nspecies)
+  use io_m, only: open_file, close_file
+  use io_m, only: iostat_update
+
+  implicit none
+
+  integer, parameter :: dp = selected_real_kind(p=15)
+
+  ! Input parameters
+  character(len=*), intent(in) :: fname
+  integer, intent(out) :: no_u, na_u, nspecies
+
+! Define f2py intents
+!f2py intent(in) :: fname
+!f2py intent(out) :: no_u, na_u, nspecies
+
 ! Internal variables and arrays
   integer :: iu, ierr
   integer :: is, ih, io
@@ -289,11 +713,11 @@ subroutine read_hsx_specie_sizes(fname, no_u, na_u, nspecies)
   read(iu, iostat=ierr) no_u, lno_s, lnspin, lmaxnh
   call iostat_update(ierr)
 
-! Read logical
+  ! Read logical
   read(iu, iostat=ierr) lGamma
   call iostat_update(ierr)
 
-! Read out indxuo
+  ! Read out indxuo
   if (.not. lGamma) then
     read(iu, iostat=ierr) ! indxuo
     call iostat_update(ierr)
@@ -302,13 +726,13 @@ subroutine read_hsx_specie_sizes(fname, no_u, na_u, nspecies)
   read(iu, iostat=ierr) ! numh
   call iostat_update(ierr)
 
-! Read listh
+  ! Read listh
   do ih = 1 , no_u
     read(iu, iostat=ierr) !listh
     call iostat_update(ierr)
   end do
 
-! Read Hamiltonian
+  ! Read Hamiltonian
   do is = 1 , lnspin
     do ih = 1 , no_u
       read(iu, iostat=ierr) ! H
@@ -316,7 +740,7 @@ subroutine read_hsx_specie_sizes(fname, no_u, na_u, nspecies)
     end do
   end do
 
-! Read Overlap matrix
+  ! Read Overlap matrix
   do ih = 1,no_u
     read(iu, iostat=ierr) ! S
     call iostat_update(ierr)
@@ -348,7 +772,7 @@ subroutine read_hsx_specie_sizes(fname, no_u, na_u, nspecies)
 
   call close_file(iu)
 
-end subroutine read_hsx_specie_sizes
+end subroutine read_hsx_specie_sizes0
 
 subroutine read_hsx_species(fname, nspecies, no_u, na_u, labelfis, zvalfis, nofis, isa)
   use io_m, only: open_file, close_file
diff --git a/sisl/io/siesta/_src/tshs_read.f90 b/sisl/io/siesta/_src/tshs_read.f90
index 38c64fd36..f05fc41b8 100644
--- a/sisl/io/siesta/_src/tshs_read.f90
+++ b/sisl/io/siesta/_src/tshs_read.f90
@@ -25,6 +25,10 @@ subroutine read_tshs_version(fname, version)
     ! we have a version
     rewind(iu)
     read(iu, iostat=ierr) version
+    if ( version /= 1 ) then
+      ! Signal we do not know about this file
+      call iostat_update(-1)
+    end if
   else
     version = 0
   end if
diff --git a/sisl/viz/backends/blender/_plots/grid.py b/sisl/viz/backends/blender/_plots/grid.py
index baf404e40..1fdaf92f0 100644
--- a/sisl/viz/backends/blender/_plots/grid.py
+++ b/sisl/viz/backends/blender/_plots/grid.py
@@ -21,21 +21,23 @@ class BlenderGridBackend(BlenderBackend, GridBackend):
             obj = bpy.data.objects.new(mesh.name, mesh)
 
             col.objects.link(obj)
-            bpy.context.view_layer.objects.active = obj
+            #bpy.context.view_layer.objects.active = obj
 
             edges = []
             mesh.from_pydata(isosurf["vertices"], edges, isosurf["faces"].tolist())
 
-            mat = bpy.data.materials.new("material")
-            mat.use_nodes = True
+            self._color_obj(obj, isosurf["color"], isosurf['opacity'])
 
-            color = self._to_rgb_color(isosurf["color"])
+            # mat = bpy.data.materials.new("material")
+            # mat.use_nodes = True
 
-            if color is not None:
-                mat.node_tree.nodes["Principled BSDF"].inputs[0].default_value = (*color, 1)
+            # color = self._to_rgb_color(isosurf["color"])
 
-            mat.node_tree.nodes["Principled BSDF"].inputs[19].default_value = isosurf["opacity"]
+            # if color is not None:
+            #     mat.node_tree.nodes["Principled BSDF"].inputs[0].default_value = (*color, 1)
 
-            mesh.materials.append(mat)
+            # mat.node_tree.nodes["Principled BSDF"].inputs[19].default_value = isosurf["opacity"]
+
+            # mesh.materials.append(mat)
 
 GridPlot.backends.register("blender", BlenderGridBackend)
diff --git a/sisl/viz/plots/bands.py b/sisl/viz/plots/bands.py
index 45c17ecb4..1602384ab 100644
--- a/sisl/viz/plots/bands.py
+++ b/sisl/viz/plots/bands.py
@@ -6,7 +6,10 @@ from functools import partial
 import itertools
 
 import numpy as np
-import xarray as xr
+try:
+    import xarray as xr
+except ModuleNotFoundError:
+    pass
 
 import sisl
 from sisl.physics.brillouinzone import BrillouinZone
